#include <iostream>
#include <filesystem>
#include <fstream>
#include <vector>

#include <cstdint>

static const uint8_t py2k2_doj_tab[256] = {
	0x74, 0xe8, 0xa8, 0x64, 0x26, 0x44, 0xa6, 0x9a, 0xa5, 0x69, 0xa2, 0xd3, 0x6d, 0xba, 0xff, 0xf3,
	0xeb, 0x6e, 0xe3, 0x70, 0x72, 0x58, 0x27, 0xd9, 0xe4, 0x9f, 0x50, 0xa2, 0xdd, 0xce, 0x6e, 0xf6,
	0x44, 0x72, 0x0c, 0x7e, 0x4d, 0x41, 0x77, 0x2d, 0x00, 0xad, 0x1a, 0x5f, 0x6b, 0xc0, 0x1d, 0x4e,
	0x4c, 0x72, 0x62, 0x3c, 0x32, 0x28, 0x43, 0xf8, 0x9d, 0x52, 0x05, 0x7e, 0xd1, 0xee, 0x82, 0x61,
	0x3b, 0x3f, 0x77, 0xf3, 0x8f, 0x7e, 0x3f, 0xf1, 0xdf, 0x8f, 0x68, 0x43, 0xd7, 0x68, 0xdf, 0x19,
	0x87, 0xff, 0x74, 0xe5, 0x3f, 0x43, 0x8e, 0x80, 0x0f, 0x7e, 0xdb, 0x32, 0xe8, 0xd1, 0x66, 0x8f,
	0xbe, 0xe2, 0x33, 0x94, 0xc8, 0x32, 0x39, 0xfa, 0xf0, 0x43, 0xde, 0x84, 0x18, 0xd0, 0x6d, 0xd5,
	0x74, 0x98, 0xf8, 0x64, 0xcf, 0x84, 0xc6, 0xea, 0x55, 0x32, 0xe2, 0x38, 0xdd, 0xea, 0xfd, 0x6c,
	0xeb, 0x6e, 0xe3, 0x70, 0xae, 0x38, 0xc7, 0xd9, 0x54, 0x84, 0x10, 0xc1, 0xfd, 0x1e, 0x6e, 0x6d,
	0x37, 0xe0, 0x03, 0x9e, 0x06, 0x36, 0x68, 0x5b, 0xe3, 0xf6, 0x7f, 0x0b, 0x56, 0x79, 0xe0, 0xa8,
	0x98, 0x77, 0xc7, 0x2b, 0xa5, 0x79, 0xff, 0x2f, 0xca, 0x15, 0x71, 0x7e, 0x02, 0xbf, 0x87, 0xb7,
	0x7a, 0x8e, 0xe6, 0x64, 0x32, 0x62, 0x2a, 0xca, 0x23, 0x72, 0x87, 0xb5, 0x0c, 0x02, 0x4b, 0xee,
	0x44, 0x72, 0x9c, 0x7e, 0x5d, 0xc1, 0xa7, 0x1d, 0x30, 0x38, 0xda, 0xc9, 0x5b, 0xd0, 0x11, 0xf9,
	0xb1, 0x72, 0x6c, 0x04, 0x31, 0xc9, 0x50, 0x60, 0x6f, 0xc1, 0xf2, 0xae, 0x00, 0xf4, 0x5d, 0x66,
	0x43, 0x0e, 0x7a, 0xc3, 0x76, 0xae, 0x3c, 0xc2, 0xb7, 0xc9, 0x52, 0xf4, 0x74, 0x51, 0xaf, 0x12,
	0x19, 0xc6, 0x75, 0xe8, 0x6c, 0x54, 0x7e, 0x63, 0xdd, 0xae, 0x07, 0x5a, 0xb7, 0x00, 0xb5, 0x5e
};

#define IGS27_ENCRYPT8 if ((i & 0x004820) == 0x004820) x ^= 0x0080;
#define IGS27_ENCRYPT7 if ((i & 0x011800) != 0x010000) x ^= 0x0040;
#define IGS27_ENCRYPT6_ALT if ((i & 0x022004) != 0x000004) x ^= 0x0020;
#define IGS27_ENCRYPT5 if ((i & 0x008100) == 0x008000) x ^= 0x0010;
#define IGS27_ENCRYPT4_ALT if ((i & 0x000042) != 0x000042) x ^= 0x0008;
#define IGS27_ENCRYPT3_ALT if((i & 0x000030) == 0x000010 && (i & 0x180000) != 0x080000) x ^= 0x0004;
#define IGS27_ENCRYPT2_ALT3 if((i & 0x004008) == 0x004008 && (i & 0x180000) != 0x000000) x ^= 0x0002;
#define IGS27_ENCRYPT1 if ((i & 0x040480) != 0x000080) x ^= 0x0001;

#define IGS27_DECRYPT1 if ((i & 0x040480) != 0x000080) x ^= 0x0001;
#define IGS27_DECRYPT2_ALT3 if((i & 0x004008) == 0x004008 && (i & 0x180000) != 0x000000) x ^= 0x0002;
#define IGS27_DECRYPT3_ALT if((i & 0x000030) == 0x000010 && (i & 0x180000) != 0x080000) x ^= 0x0004;
#define IGS27_DECRYPT4_ALT if ((i & 0x000042) != 0x000042) x ^= 0x0008;
#define IGS27_DECRYPT5 if ((i & 0x008100) == 0x008000) x ^= 0x0010;
#define IGS27_DECRYPT6_ALT if ((i & 0x022004) != 0x000004) x ^= 0x0020;
#define IGS27_DECRYPT7 if ((i & 0x011800) != 0x010000) x ^= 0x0040;
#define IGS27_DECRYPT8 if ((i & 0x004820) == 0x004820) x ^= 0x0080;

enum OPERATION {
  ENCRYPT,
  DECRYPT,
};

void process(OPERATION op, std::string irom_path) {
  // Open the raw ROM file for reading
  std::ifstream irom(irom_path, std::ios::binary);
  if (!irom) {
    std::cerr << "Error opening ROM file" << std::endl;
    return;
  }

  // Read the file contents into a vector (rom_size is the total size of the ROM file)
  irom.seekg(0, std::ios::end);
  std::streamsize rom_size = irom.tellg();
  irom.seekg(0, std::ios::beg);

  std::vector<uint8_t> rom_data(rom_size);
  if (!irom.read(reinterpret_cast<char*>(rom_data.data()), rom_size)) {
    std::cerr << "Error reading ROM file!" << std::endl;
    return;
  }
  irom.close();

  // Iterate through the ROM data in 16-bit chunks (2 bytes at a time)
  for (size_t i = 0; i < rom_size / 2; i++) {
    uint16_t x = (rom_data[i * 2 + 1] << 8) | rom_data[i * 2]; // Combine 2 bytes into 16-bit value

    if (op == DECRYPT) {
      IGS27_DECRYPT1
      IGS27_DECRYPT2_ALT3
      IGS27_DECRYPT3_ALT
      IGS27_DECRYPT4_ALT
      IGS27_DECRYPT5
      IGS27_DECRYPT6_ALT
      IGS27_DECRYPT7
      IGS27_DECRYPT8
    } else if (op == ENCRYPT) {
      IGS27_ENCRYPT8
      IGS27_ENCRYPT7
      IGS27_ENCRYPT6_ALT
      IGS27_ENCRYPT5
      IGS27_ENCRYPT4_ALT
      IGS27_ENCRYPT3_ALT
      IGS27_ENCRYPT2_ALT3
      IGS27_ENCRYPT1
    }

    // Apply the table lookup and XOR with the result
    x ^= py2k2_doj_tab[i & 0xff] << 8;

    // Split the 16-bit value back into two bytes and store it
    rom_data[i * 2] = x & 0xFF;
    rom_data[i * 2 + 1] = (x >> 8) & 0xFF;
  }

  // Open the output ROM file for writing
  std::filesystem::path fs_irom(irom_path);
  std::string filename = fs_irom.stem().string();
  std::string extension = fs_irom.extension().string();
  std::string orom_path;

  if (op == ENCRYPT) {
    orom_path = filename + "-encrypt" + extension;
  } else if (op == DECRYPT) {
    orom_path = filename + "-decrypt" + extension;
  }
  std::ofstream orom(orom_path, std::ios::binary);
  if (!orom) {
    std::cerr << "Error opening output ROM file" << std::endl;
    return;
  }

  // Write the decrypted data back to the output file
  if (!orom.write(reinterpret_cast<char*>(rom_data.data()), rom_size)) {
    std::cerr << "Error writing to output ROM file" << std::endl;
    return;
  }
  orom.close();
}

void decrypt(std::string irom_path) {
  process(DECRYPT, irom_path);
}

void encrypt(std::string irom_path) {
  process(ENCRYPT, irom_path);
}

int main(int argc, char *argv[]) {
  // Check if the correct number of arguments is passed
  if (argc != 3) {
    std::cerr << "Usage: ./crypt [ROM] [encrypt/decrypt]" << std::endl;
    return 1;
  }

  std::string rom = argv[1];
  std::string operation = argv[2];

  if (operation == "encrypt")
    encrypt(rom);
  else if (operation == "decrypt") {
    decrypt(rom);
  } else {
    std::cerr << "Unknown operation: " << operation << std::endl;
    return 1;
  }

  std::cout << "done" << std::endl;
  return 0;
}
